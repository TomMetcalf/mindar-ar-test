<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
  <style>
    body { margin:0; font-family:sans-serif; }

    /* Full screen overlays */
    #whiteOverlay, #inactiveTabMessage {
      position: fixed; top:0; left:0; width:100%; height:100%;
      display:flex; align-items:center; justify-content:center;
      background:white; z-index:10;
    }

    /* Start/Restart buttons container */
    #preARMessage {
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      height:100%;
      gap: 1em;
    }

    #startAR, #restartAR {
      padding:1em 2em; font-size:18px; cursor:pointer;
    }
    #restartAR { display:none; }

    #audioToggle {
      position: fixed; bottom:5%; right:5%; z-index:20; padding:0.5em 1em; font-size:18px; cursor:pointer; display:none;
    }

    #arScene { display:none; }

    #stillWatchingContainer {
      position: fixed; top:0; left:0; width:100%; height:100%;
      background:white; z-index:50; display:none;
      align-items:center; justify-content:center;
    }

    #stillWatchingBtn {
      padding:1em 2em; font-size:18px; cursor:pointer;
    }

    /* Inactive tab message formatting */
    #inactiveTabMessage {
      display: none; /* hidden by default */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 0 1em;
      box-sizing: border-box;
    }
    #inactiveTabInner {
      max-width: 600px;
      width: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    #inactiveTabInner p {
      margin: 0.5em 0;
      font-size: 1.2em;
      word-wrap: break-word;
    }
    @media (max-width: 480px) { #inactiveTabInner p { font-size: 1em; } }
    @media (max-width: 360px) { #inactiveTabInner p { font-size: 0.9em; } }
  </style>
</head>
<body>

  <!-- Pre-AR Overlay -->
  <div id="whiteOverlay">
    <div id="preARMessage">
      <button id="startAR">Start AR</button>
      <button id="restartAR">Restart AR</button>
    </div>
  </div>

  <!-- Message for second tab -->
  <div id="inactiveTabMessage">
    <div id="inactiveTabInner">
      <p>AR is already active in another tab.</p>
      <p>Please close this tab and switch back to the active tab to continue using AR.</p>
    </div>
  </div>

  <!-- Still Watching -->
  <div id="stillWatchingContainer">
    <button id="stillWatchingBtn">Still Watching?</button>
  </div>

  <button id="audioToggle">ðŸ”‡</button>
  <video id="videoA" style="display:none" muted playsinline></video>
  <video id="videoB" style="display:none" muted playsinline></video>

  <a-scene
    id="arScene"
    mindar-image="imageTargetSrc: ./assets/targets/targets.mind; smooth:true; smoothCount:5; smoothTolerance:0.1"
    color-space="sRGB"
    renderer="colorManagement:true, physicallyCorrectLights"
    vr-mode-ui="enabled:false"
    device-orientation-permission-ui="enabled:false"
    framerate="12"
    look-at="[camera]"
  >
    <a-camera id="camera" position="0 0 0" look-controls="enabled:false"></a-camera>
    <a-entity id="target0" mindar-image-target="targetIndex:0">
      <a-plane id="videoPlaneA" width="1.2" height="1.2" position="0 0 0" look-at="[camera]" visible="false" material="shader:flat; src:#videoA"></a-plane>
      <a-plane id="videoPlaneB" width="1.2" height="1.2" position="0 0 0" look-at="[camera]" visible="false" material="shader:flat; src:#videoB"></a-plane>
    </a-entity>
  </a-scene>

<script>
(async ()=>{
  /* --------------------------
     OWNER / WATCHER mechanism
     - OWNER_KEY stores JSON { tabId, lastSeen }
     - only the owner pulses lastSeen
     - watchers poll for owner staleness and try to claim
     - claiming does NOT auto-start AR; it only grants the Start/Restart UI
     -------------------------- */
  const OWNER_KEY = 'arOwner';
  const OWNER_PULSE_MS = 1000;
  const OWNER_TIMEOUT_MS = 5000;
  const myId = `${Date.now()}-${Math.random().toString(16).slice(2)}`;

  let isOwner = false;
  let ownerPulseTimer = null;
  let watcherTimer = null;

  function nowTs(){ return Date.now(); }
  function setOwnerRecord(rec){ localStorage.setItem(OWNER_KEY, JSON.stringify(rec)); }
  function getOwnerRecord(){ try { return JSON.parse(localStorage.getItem(OWNER_KEY)); } catch { return null; } }
  function ownerIsFresh(rec){ return !!rec && !!rec.lastSeen && (nowTs() - rec.lastSeen) < OWNER_TIMEOUT_MS; }

  function startOwnerPulse(){
    stopOwnerPulse();
    // write immediately and then interval
    setOwnerRecord({ tabId: myId, lastSeen: nowTs() });
    ownerPulseTimer = setInterval(()=>{
      setOwnerRecord({ tabId: myId, lastSeen: nowTs() });
    }, OWNER_PULSE_MS);
  }
  function stopOwnerPulse(){
    if(ownerPulseTimer){ clearInterval(ownerPulseTimer); ownerPulseTimer = null; }
  }

  function startWatcher(){
    stopWatcher();
    watcherTimer = setInterval(()=>{
      const rec = getOwnerRecord();
      if(!ownerIsFresh(rec)){
        // try to claim
        attemptClaim();
      }
    }, Math.max(OWNER_PULSE_MS, 1500));
  }
  function stopWatcher(){ if(watcherTimer){ clearInterval(watcherTimer); watcherTimer = null; } }

  function showInactiveMessage(){
    document.getElementById("whiteOverlay").style.display="none";
    document.getElementById("inactiveTabMessage").style.display="flex";
  }
  function hideInactiveMessage(){
    document.getElementById("inactiveTabMessage").style.display="none";
  }

  // When we become owner, show the Start/Restart UI (but DO NOT start AR automatically)
  function onBecameOwner(){
    isOwner = true;
    hideInactiveMessage();
    // pulse owner record and start owner updater
    startOwnerPulse();
    stopWatcher();
    // ensure the overlay is visible (so user can press start/restart)
    document.getElementById("whiteOverlay").style.display = "flex";
    // initialize AR wiring (listeners, preload) if not already
    if(!window.__arInited) {
      window.__arInited = true;
      initAR(); // sets up everything but doesn't auto-play
    }
  }

  // When we lose ownership (another tab takes over), stop AR session and show inactive message
  function onLostOwnership(){
    isOwner = false;
    stopOwnerPulse();
    // stop any active AR run (pause/stop media), but keep listeners
    stopARSession();
    showInactiveMessage();
    // start watching owner so we can try to claim when stale
    startWatcher();
  }

  // Try to claim ownership: if owner missing or stale, set owner to us, verify
  function attemptClaim(){
    const existing = getOwnerRecord();
    if(!existing || !ownerIsFresh(existing)){
      // try take over
      setOwnerRecord({ tabId: myId, lastSeen: nowTs() });
    }
    const verify = getOwnerRecord();
    if(verify && verify.tabId === myId){
      onBecameOwner();
    } else {
      // remain watcher
      showInactiveMessage();
      startWatcher();
    }
  }

  // Listen for external owner changes
  window.addEventListener('storage', (e)=>{
    if(e.key !== OWNER_KEY) return;
    const rec = getOwnerRecord();
    if(isOwner){
      // if someone else became owner, relinquish
      if(rec && rec.tabId && rec.tabId !== myId){
        onLostOwnership();
      }
    } else {
      // if owner cleared or stale, try to claim
      if(!ownerIsFresh(rec)){
        attemptClaim();
      } else {
        // there is a fresh owner -> stay watcher
        showInactiveMessage();
        startWatcher();
      }
    }
  });

  // Best-effort: on unload if we are owner, remove OWNER_KEY
  window.addEventListener('beforeunload', ()=>{
    if(isOwner){
      const rec = getOwnerRecord();
      if(rec && rec.tabId === myId) localStorage.removeItem(OWNER_KEY);
    }
  });

  // Initial attempt to become owner
  attemptClaim();

  /* -----------------------
     AR logic (listeners, preloads, start/stop)
     - initAR() sets up event handlers and preloads
     - startARSession() is called by pressing Start/Restart (only runs if isOwner)
     - stopARSession() cleans up playback (pause videos, stop audio, hide planes)
     ----------------------- */

  // Shared state holders so functions below can see them
  let shared = {
    // flags
    lastIndex: -1,
    activeVideo: null,
    nextVideo: null,
    activePlane: null,
    nextPlane: null,
    isActive: false,
    loopCount: 0,
    monitorRunning: false,
    arStartedOnce: false,
    startClicked: false,
    arButtonPressed: false,
    targetCurrentlyVisible: false,
    audioCtx: null, audioBuffer: null, audioSource: null, audioLoaded:false,
  };

  // stopARSession used when losing ownership
  function stopARSession(){
    try {
      if(shared.activeVideo){ shared.activeVideo.pause(); }
      if(shared.nextVideo){ shared.nextVideo.pause(); }
      if(shared.audioSource){
        try{ shared.audioSource.stop(); }catch{}
        shared.audioSource.disconnect();
        shared.audioSource = null;
      }
    } catch(e){ /* ignore */ }
    // hide planes
    try {
      document.getElementById("videoPlaneA").setAttribute("visible", false);
      document.getElementById("videoPlaneB").setAttribute("visible", false);
    } catch(e){}
    shared.isActive = false;
    shared.loopCount = 0;
    // hide audio toggle
    document.getElementById("audioToggle").style.display = "none";
  }

  // initAR() sets up everything but does NOT start playing until startARSession() is called.
  async function initAR(){
    const whiteOverlay = document.getElementById("whiteOverlay");
    const startBtn = document.getElementById("startAR");
    const restartBtn = document.getElementById("restartAR");
    const audioToggleBtn = document.getElementById("audioToggle");
    const videoA = document.getElementById("videoA");
    const videoB = document.getElementById("videoB");
    const videoPlaneA = document.getElementById("videoPlaneA");
    const videoPlaneB = document.getElementById("videoPlaneB");
    const targetEl = document.getElementById("target0");
    const arScene = document.getElementById("arScene");
    const stillWatchingContainer = document.getElementById("stillWatchingContainer");
    const stillWatchingBtn = document.getElementById("stillWatchingBtn");
    const TOTAL_VIDEOS = 60;

    // wire shared refs
    shared.activeVideo = videoA;
    shared.nextVideo = videoB;
    shared.activePlane = videoPlaneA;
    shared.nextPlane = videoPlaneB;

    // restore some flags
    shared.lastIndex = -1;
    shared.loopCount = 0;

    // audio preference
    let userAudioPreference = localStorage.getItem("userAudioPref");
    userAudioPreference = userAudioPreference === null ? true : userAudioPreference !== "false";

    async function loadAudioOnce(){
      if(shared.audioLoaded) return;
      shared.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const response = await fetch("./assets/audio/background.mp3");
      const arrayBuffer = await response.arrayBuffer();
      shared.audioBuffer = await shared.audioCtx.decodeAudioData(arrayBuffer);
      shared.audioLoaded = true;
    }

    function playAudio(){
      if(!shared.audioBuffer) return;
      stopAudio();
      shared.audioSource = shared.audioCtx.createBufferSource();
      shared.audioSource.buffer = shared.audioBuffer;
      shared.audioSource.loop = true;
      shared.audioSource.connect(shared.audioCtx.destination);
      shared.audioSource.start(0);
      audioToggleBtn.textContent = "ðŸ”Š";
    }

    function stopAudio(){
      if(shared.audioSource){
        try{ shared.audioSource.stop(); }catch{}
        try{ shared.audioSource.disconnect(); }catch{}
        shared.audioSource = null;
      }
      audioToggleBtn.textContent = "ðŸ”‡";
    }

    function pickRandomIndex(){
      let idx;
      do { idx = Math.floor(Math.random() * TOTAL_VIDEOS); } while (idx === shared.lastIndex);
      shared.lastIndex = idx;
      return idx;
    }

    function preloadVideo(videoEl){
      const idx = pickRandomIndex();
      videoEl.src = `./assets/videos/target0_random_${idx}.mp4`;
      videoEl.currentTime = 0;
      videoEl.load();
    }

    function swapVideo(){
      const flip = Math.random() < 0.5 ? -1 : 1;
      shared.nextPlane.setAttribute("scale", `${flip} 1 1`);
      shared.nextPlane.setAttribute("visible", true);
      shared.activePlane.setAttribute("visible", false);
      shared.nextVideo.currentTime = 0;
      shared.nextVideo.play();
      [shared.activeVideo, shared.nextVideo] = [shared.nextVideo, shared.activeVideo];
      [shared.activePlane, shared.nextPlane] = [shared.nextPlane, shared.activePlane];
      preloadVideo(shared.nextVideo);
      shared.loopCount++;
      if (shared.loopCount >= 3) {
        showStillWatching();
      }
    }

    function monitorVideo(){
      if(shared.monitorRunning) return; // only one loop
      shared.monitorRunning = true;
      (function loop(){
        try {
          if(shared.isActive && shared.activeVideo && shared.activeVideo.duration > 0 &&
             shared.activeVideo.currentTime >= shared.activeVideo.duration - 0.05) {
            swapVideo();
          }
        } catch(e){}
        if(shared.monitorRunning) requestAnimationFrame(loop);
      })();
    }

    function showStillWatching(){
      shared.isActive = false;
      try { shared.activeVideo.pause(); shared.nextVideo.pause(); } catch(e){}
      stopAudio();
      audioToggleBtn.style.display = "none";
      stillWatchingContainer.style.display = "flex";
    }

    stillWatchingBtn.addEventListener("click", async ()=>{
      stillWatchingContainer.style.display = "none";
      shared.loopCount = 0;
      shared.isActive = true;
      try { shared.activeVideo.play(); } catch(e){}
      shared.activePlane.setAttribute("visible", true);
      if(userAudioPreference){ await loadAudioOnce(); playAudio(); }
      audioToggleBtn.style.display = "block";
    });

    async function handleTargetFound(){
      if(!shared.arButtonPressed) return;
      shared.isActive = true;
      shared.activePlane.setAttribute("visible", true);
      arScene.style.background = "#ffffff";
      if (!shared.activeVideo.src) { preloadVideo(shared.activeVideo); preloadVideo(shared.nextVideo); }
      try { shared.activeVideo.play(); } catch(e){}
      if(userAudioPreference){ await loadAudioOnce(); playAudio(); }
      audioToggleBtn.style.display = "block";
    }

    // start / restart UI wiring
    startBtn.addEventListener("click", ()=>{
      if(!isOwner) return; // safety
      shared.startClicked = true;
      shared.arButtonPressed = true;
      shared.arStartedOnce = true;
      document.getElementById("whiteOverlay").style.display = "none";
      document.getElementById("arScene").style.display = "block";
      monitorVideo();
      if(shared.targetCurrentlyVisible) handleTargetFound();
    });

    restartBtn.addEventListener("click", ()=>{
      if(!isOwner) return;
      shared.startClicked = true;
      shared.arButtonPressed = true;
      document.getElementById("whiteOverlay").style.display = "none";
      document.getElementById("arScene").style.display = "block";
      monitorVideo();
      if(shared.targetCurrentlyVisible) handleTargetFound();
    });

    audioToggleBtn.addEventListener("click", async ()=>{
      await loadAudioOnce();
      if(!shared.audioSource){ playAudio(); userAudioPreference = true; }
      else { stopAudio(); userAudioPreference = false; }
      localStorage.setItem("userAudioPref", userAudioPreference);
    });

    // MindAR target events
    targetEl.addEventListener("targetFound", ()=>{
      shared.targetCurrentlyVisible = true;
      if(shared.arButtonPressed) handleTargetFound();
    });

    targetEl.addEventListener("targetLost", ()=>{
      shared.targetCurrentlyVisible = false;
      shared.isActive = false;
      try { shared.activePlane.setAttribute("visible", false); shared.nextPlane.setAttribute("visible", false); } catch(e){}
      document.getElementById("arScene").style.background = null;
      try { shared.activeVideo.pause(); shared.nextVideo.pause(); } catch(e){}
      stopAudio();
      audioToggleBtn.style.display = "none";
    });

    // visibility handling: when tab becomes visible, show overlay and proper button
    document.addEventListener("visibilitychange", ()=>{
      if(document.hidden){
        shared.isActive = false;
        try { shared.activeVideo.pause(); shared.nextVideo.pause(); } catch(e){}
        stopAudio();
        audioToggleBtn.style.display = "none";
        try { shared.activePlane.setAttribute("visible", false); shared.nextPlane.setAttribute("visible", false); } catch(e){}
      } else {
        // If we are the owner, show overlay allowing restart
        if(isOwner){
          document.getElementById("whiteOverlay").style.display = "block";
          document.getElementById("arScene").style.display = "none";
          audioToggleBtn.style.display = "none";
          if(shared.arStartedOnce){
            startBtn.style.display = "none";
            restartBtn.style.display = "block";
            // require explicit press again
            shared.arButtonPressed = false;
          } else {
            startBtn.style.display = "block";
            restartBtn.style.display = "none";
          }
        } else {
          // watcher: ensure inactive shown
          showInactiveMessage();
        }
      }
    });

    // Prewarm two videos & audio
    [videoA, videoB].forEach(v => { try { v.currentTime = 0; v.play(); v.pause(); } catch(e){} });
    preloadVideo(videoA);
    preloadVideo(videoB);
    // don't force load audio now, defer until user interacts (some devices restrict AutoAudio)
    // but we can decode in background if desired. We'll leave as before.
  } // end initAR

  // Helper to attempt claim immediately when owner cleared programmatically
  // (e.g. during testing) - watchers will poll anyway.
  // End of main IIFE
})();
</script>

</body>
</html>
