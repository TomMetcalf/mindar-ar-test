<!doctype html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
  <style>
    body { margin:0; overflow:hidden; }
    #whiteOverlay{
      position:fixed; top:0; left:0;
      width:100%; height:100%;
      background:white; z-index:50;
      display:block;
    }
    #startAR{
      position:fixed; top:40%; left:50%;
      transform:translate(-50%,-50%);
      z-index:60; padding:1em 2em; font-size:18px; cursor:pointer;
    }
    #audioToggle{
      position:fixed; right:5%; bottom:5%; z-index:60;
      padding:.5em 1em; display:none; cursor:pointer;
    }
    #stillWatchingOverlay{
      position:fixed; top:0; left:0; width:100%; height:100%;
      background:white; z-index:70; display:none;
      align-items:center; justify-content:center;
    }
    #stillWatchingBtn{ padding:1em 2em; font-size:18px; cursor:pointer; }
  </style>
</head>
<body>
  <div id="whiteOverlay"></div>
  <button id="startAR">Start AR</button>
  <button id="audioToggle">ðŸ”Š Play Audio</button>

  <div id="stillWatchingOverlay"><button id="stillWatchingBtn">Continue Watching</button></div>

  <video id="videoA" style="display:none" muted playsinline></video>
  <video id="videoB" style="display:none" muted playsinline></video>

  <audio id="bgAudio" loop playsinline>
    <source src="./assets/audio/background.mp3" type="audio/mpeg">
  </audio>

  <a-scene id="arScene"
    mindar-image="imageTargetSrc: ./assets/targets/targets.mind; smooth: true; smoothCount: 5; smoothTolerance: 0.1"
    color-space="sRGB"
    renderer="colorManagement: true, physicallyCorrectLights"
    vr-mode-ui="enabled:false"
    device-orientation-permission-ui="enabled:false"
    framerate="12"
    look-at="[camera]"
  >
    <a-camera position="0 0 0" look-controls="enabled:false"></a-camera>
    <a-entity id="target0" mindar-image-target="targetIndex: 0">
      <a-plane id="videoPlane" width="1.2" height="1.2" position="0 0 0" look-at="[camera]" material="shader: flat; src: #videoA" visible="false"></a-plane>
    </a-entity>
  </a-scene>

<script>
/* --------- Config --------- */
const TOTAL_VIDEOS = 60;
const LOOP_LIMIT_BEFORE_STILL = 10;
const POLL_INTERVAL_MS = 120;   // how often to poll MindAR after Start AR
const POLL_TIMEOUT_MS = 2000;   // how long to poll before giving up

/* --------- DOM --------- */
const whiteOverlay = document.getElementById('whiteOverlay');
const startBtn = document.getElementById('startAR');
const audioToggleBtn = document.getElementById('audioToggle');
const stillWatchingOverlay = document.getElementById('stillWatchingOverlay');
const stillWatchingBtn = document.getElementById('stillWatchingBtn');
const videoPlane = document.getElementById('videoPlane');
const targetEl = document.getElementById('target0');
const videoA = document.getElementById('videoA');
const videoB = document.getElementById('videoB');
const bgAudio = document.getElementById('bgAudio');
const sceneEl = document.querySelector('a-scene');

/* --------- State --------- */
let activeVideo = videoA;
let nextVideo = videoB;
let lastIndex = -1;
let isActive = false;
let startClicked = false;
let loops = 0;
let userAudioPref = localStorage.getItem('audioPref') !== 'false';

/* --------- Helpers --------- */
function pickRandomIndex(){
  let idx;
  do { idx = Math.floor(Math.random()*TOTAL_VIDEOS); } while(idx === lastIndex);
  lastIndex = idx;
  return idx;
}

function preloadVideo(videoEl){
  const idx = pickRandomIndex();
  videoEl.src = `./assets/videos/target0_random_${idx}.mp4`;
  videoEl.currentTime = 0;
  // try to fetch quickly
  try { videoEl.load(); } catch(e){ console.warn('video load failed', e); }
}

async function tryPlayVideo(el){
  try {
    await el.play();
    return true;
  } catch(e){
    console.warn('video.play() rejected', e);
    return false;
  }
}

/* swap / loop logic */
function swapVideo(){
  const flip = Math.random() < 0.5;
  videoPlane.setAttribute('scale', flip ? '-1 1 1' : '1 1 1');
  videoPlane.setAttribute('material', 'src', nextVideo);
  nextVideo.play().catch(()=>{});
  [activeVideo, nextVideo] = [nextVideo, activeVideo];
  preloadVideo(nextVideo);

  loops++;
  if(loops >= LOOP_LIMIT_BEFORE_STILL){
    // pause and show still-watching overlay
    isActive = false;
    activeVideo.pause();
    nextVideo.pause();
    if(!bgAudio.paused) bgAudio.pause();
    stillWatchingOverlay.style.display = 'flex';
    // whiteOverlay behind still-watching is already white; we use overlay container
  }
}

function monitorVideo(){
  if(isActive && activeVideo.duration > 0 && activeVideo.currentTime >= activeVideo.duration - 0.05){
    swapVideo();
  }
  requestAnimationFrame(monitorVideo);
}

/* --------- MindAR visibility check: try multiple fallbacks --------- */
function mindarTargetVisibleFallback(){
  try{
    // 1) Preferred: component on target entity (common in many examples)
    const comp = targetEl.components && targetEl.components['mindar-image-target'];
    if(comp && typeof comp.isTargetVisible !== 'undefined'){
      return !!comp.isTargetVisible;
    }
  } catch(e){ /* ignore */ }

  try{
    // 2) scene.systems variants (try a few names)
    const s = sceneEl;
    const sysCandidates = [
      s.systems['mindar-image-system'],
      s.systems['mindar-image'],
      s.components && s.components['mindar-image'],
      s.systems && s.systems['mindar-image-system']
    ];
    for(const cand of sysCandidates){
      if(!cand) continue;
      // network of possible properties
      if(Array.isArray(cand.trackedTargets) && cand.trackedTargets.includes(0)) return true;
      if(Array.isArray(cand.trackedTargetIndices) && cand.trackedTargetIndices.includes(0)) return true;
      // some internals store a controller with imageTrackers
      const ctrl = cand.controller || cand._controller || cand.mindarThree || cand.controller;
      if(ctrl && Array.isArray(ctrl.imageTrackers)){
        if(ctrl.imageTrackers[0] && ctrl.imageTrackers[0].targetVisible) return true;
      }
      // some implementations expose trackedTargets map
      if(cand.trackedTargets && cand.trackedTargets[0]) return true;
    }
  } catch(e){ /* ignore */ }

  // nothing found
  return false;
}

/* Poll until either the target is visible or timeout */
function pollTargetVisible(timeoutMs=POLL_TIMEOUT_MS, intervalMs=POLL_INTERVAL_MS){
  return new Promise((resolve) => {
    if(mindarTargetVisibleFallback()) return resolve(true);
    const start = Date.now();
    const id = setInterval(()=>{
      if(mindarTargetVisibleFallback()){
        clearInterval(id);
        return resolve(true);
      }
      if(Date.now() - start >= timeoutMs){
        clearInterval(id);
        return resolve(false);
      }
    }, intervalMs);
  });
}

/* --------- Target found handler (reusable) --------- */
async function handleTargetFound(){
  if(!startClicked) return;
  if(isActive) return; // already running
  isActive = true;
  loops = 0;
  videoPlane.setAttribute('visible', true);
  sceneEl.object3D.background = new THREE.Color(0xffffff);

  // ensure videos are preloaded and ready
  if(!videoA.src) preloadVideo(videoA);
  if(!videoB.src) preloadVideo(videoB);

  // attempt to play activeVideo (best-effort)
  try { await tryPlayVideo(activeVideo); } catch(e){ /* ignore */ }

  // attempt to play audio if preference true (Start AR click is a user gesture)
  if(userAudioPref){
    try { await bgAudio.play(); audioToggleBtn.textContent = 'ðŸ”‡ Pause Audio'; } catch(e){ console.warn('audio play failed', e); }
  }

  audioToggleBtn.style.display = 'block';
}

/* --------- Start AR click behavior (robust) --------- */
startBtn.addEventListener('click', async () => {
  startClicked = true;
  whiteOverlay.style.display = 'none';
  startBtn.style.display = 'none';
  stillWatchingOverlay.style.display = 'none';
  videoPlane.setAttribute('visible', false);
  // reset video playback positions to avoid stuck frames
  try { activeVideo.pause(); nextVideo.pause(); activeVideo.currentTime = 0; nextVideo.currentTime = 0; } catch(e){}

  // start monitor loop
  monitorVideo();

  // 1) immediate check: if MindAR already considers target visible, start immediately
  if(mindarTargetVisibleFallback()){
    await handleTargetFound();
    return;
  }

  // 2) otherwise poll for a short time: if the AR system is still coming up after unlock
  const foundDuringPoll = await pollTargetVisible();
  if(foundDuringPoll){
    await handleTargetFound();
  } else {
    // not found within timeout -> we rely on normal 'targetFound' event later
    // leave audio button hidden until actual targetFound event
  }
});

/* --------- Audio toggle button --------- */
audioToggleBtn.addEventListener('click', async ()=>{
  try{
    if(bgAudio.paused){
      await bgAudio.play();
      audioToggleBtn.textContent = 'ðŸ”‡ Pause Audio';
      userAudioPref = true;
    } else {
      bgAudio.pause();
      audioToggleBtn.textContent = 'ðŸ”Š Play Audio';
      userAudioPref = false;
    }
    localStorage.setItem('audioPref', userAudioPref);
  }catch(e){ console.warn('audio toggle error', e); }
});

/* --------- Still-watching button overlay --------- */
stillWatchingBtn.addEventListener('click', async ()=>{
  stillWatchingOverlay.style.display = 'none';
  loops = 0;
  if(!isActive){
    isActive = true;
  }
  try { await tryPlayVideo(activeVideo); } catch(e){}
  if(userAudioPref){
    try { await bgAudio.play(); } catch(e){}
  }
});

/* --------- MindAR event wiring --------- */
targetEl.addEventListener('targetFound', async () => {
  // when the hardware detection emits targetFound, handle it (unless we haven't started AR)
  await handleTargetFound();
});

targetEl.addEventListener('targetLost', () => {
  isActive = false;
  videoPlane.setAttribute('visible', false);
  sceneEl.object3D.background = null;
  try { activeVideo.pause(); nextVideo.pause(); } catch(e){}
  if(!bgAudio.paused) bgAudio.pause();
  audioToggleBtn.style.display = 'none';
  stillWatchingOverlay.style.display = 'none';
});

/* --------- Visibility/lock handling: reset on hidden --------- */
document.addEventListener('visibilitychange', () => {
  if(document.hidden){
    // full reset on lock/hidden: require Start AR again
    startClicked = false;
    isActive = false;
    try { activeVideo.pause(); nextVideo.pause(); } catch(e){}
    if(!bgAudio.paused) bgAudio.pause();
    audioToggleBtn.style.display = 'none';
    stillWatchingOverlay.style.display = 'none';
    videoPlane.setAttribute('visible', false);
    whiteOverlay.style.display = 'block';
    startBtn.style.display = 'block';
    loopsSincePrompt = 0;
  }
});

/* --------- kick off minimal loop monitor (keeps requestAnimationFrame alive) --------- */
monitorVideo();
</script>
</body>
</html>
