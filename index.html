<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
  <style>
    body { margin:0; font-family:sans-serif; }
    /* ... your styles left unchanged ... */
    #whiteOverlay, #inactiveTabMessage {
      position: fixed; top:0; left:0; width:100%; height:100%;
      display:flex; align-items:center; justify-content:center;
      background:white; z-index:10;
    }
    #preARMessage{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;gap:1em;}
    #startAR,#restartAR{padding:1em 2em;font-size:18px;cursor:pointer;}
    #restartAR{display:none;}
    #audioToggle{position:fixed;bottom:5%;right:5%;z-index:20;padding:0.5em 1em;font-size:18px;cursor:pointer;display:none;}
    #arScene{display:none;}
    #stillWatchingContainer{position:fixed;top:0;left:0;width:100%;height:100%;background:white;z-index:50;display:none;align-items:center;justify-content:center;}
    #stillWatchingBtn{padding:1em 2em;font-size:18px;cursor:pointer;}
    #inactiveTabMessage{display:none;flex-direction:column;align-items:center;justify-content:center;text-align:center;padding:0 1em;box-sizing:border-box;}
    #inactiveTabInner{max-width:600px;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;}
    #inactiveTabInner p{margin:0.5em 0;font-size:1.2em;word-wrap:break-word;}
    @media (max-width:480px){#inactiveTabInner p{font-size:1em}} @media (max-width:360px){#inactiveTabInner p{font-size:0.9em}}
  </style>
</head>
<body>

  <!-- Pre-AR Overlay -->
  <div id="whiteOverlay">
    <div id="preARMessage">
      <button id="startAR">Start AR</button>
      <button id="restartAR">Restart AR</button>
    </div>
  </div>

  <!-- Message for second tab -->
  <div id="inactiveTabMessage">
    <div id="inactiveTabInner">
      <p>AR is already active in another tab.</p>
      <p>Please close this tab and switch back to the active tab to continue using AR.</p>
    </div>
  </div>

  <!-- Still Watching -->
  <div id="stillWatchingContainer">
    <button id="stillWatchingBtn">Still Watching?</button>
  </div>

  <button id="audioToggle">ðŸ”‡</button>
  <video id="videoA" style="display:none" muted playsinline></video>
  <video id="videoB" style="display:none" muted playsinline></video>

  <a-scene
    id="arScene"
    mindar-image="imageTargetSrc: ./assets/targets/targets.mind; smooth:true; smoothCount:5; smoothTolerance:0.1"
    color-space="sRGB"
    renderer="colorManagement:true, physicallyCorrectLights"
    vr-mode-ui="enabled:false"
    device-orientation-permission-ui="enabled:false"
    framerate="12"
    look-at="[camera]"
  >
    <a-camera id="camera" position="0 0 0" look-controls="enabled:false"></a-camera>
    <a-entity id="target0" mindar-image-target="targetIndex:0">
      <a-plane id="videoPlaneA" width="1.2" height="1.2" position="0 0 0" look-at="[camera]" visible="false" material="shader:flat; src:#videoA"></a-plane>
      <a-plane id="videoPlaneB" width="1.2" height="1.2" position="0 0 0" look-at="[camera]" visible="false" material="shader:flat; src:#videoB"></a-plane>
    </a-entity>
  </a-scene>

<script>
(async ()=>{
  // ---------- Ownership config ----------
  const AR_KEY = "arOwner"; // localStorage key
  const TAB_ID = Date.now() + "-" + Math.random().toString(36).slice(2);
  const HEARTBEAT_INTERVAL = 1000; // ms while visible
  const OWNER_EXPIRY = 5000; // ms: consider an owner stale after this (adjust as needed)

  let hbTimer = null;
  let bc = null;

  // Try BroadcastChannel if supported
  if ('BroadcastChannel' in window) {
    try { bc = new BroadcastChannel('ar_channel'); }
    catch(e){ bc = null; }
  }

  function readOwner(){
    try {
      const raw = localStorage.getItem(AR_KEY);
      return raw ? JSON.parse(raw) : null;
    } catch(e){ return null; }
  }
  function writeOwner(obj){
    try { localStorage.setItem(AR_KEY, JSON.stringify(obj)); } catch(e){}
  }
  function clearOwner(){
    try { localStorage.removeItem(AR_KEY); } catch(e){}
  }

  function isOwnerFresh(owner){
    if(!owner || !owner.lastSeen) return false;
    return (Date.now() - owner.lastSeen) < OWNER_EXPIRY;
  }

  function showInactiveMessage(){
    document.getElementById("whiteOverlay").style.display="none";
    document.getElementById("inactiveTabMessage").style.display="flex";
  }

  function startHeartbeatIfNeeded(){
    // heartbeat updates lastSeen while this tab is visible and is the owner
    if (hbTimer) return;
    if (document.visibilityState !== 'visible') return;
    hbTimer = setInterval(()=>{
      const cur = readOwner();
      if (cur && cur.id === TAB_ID){
        writeOwner({ id: TAB_ID, lastSeen: Date.now() });
      } else {
        // someone else reclaimed, stop heartbeat
        stopHeartbeat();
      }
    }, HEARTBEAT_INTERVAL);
  }
  function stopHeartbeat(){
    if(hbTimer){ clearInterval(hbTimer); hbTimer = null; }
  }

  function broadcast(msg){
    if(bc) try{ bc.postMessage(msg); } catch(e){}
    // also write to localStorage to wake other tabs on older browsers
    try { localStorage.setItem("ar_bcast", JSON.stringify({...msg, t: Date.now()})); } catch(e){}
  }

  function claimOwnership(){
    writeOwner({ id: TAB_ID, lastSeen: Date.now() });
    broadcast({ type: "claim", id: TAB_ID });
    startHeartbeatIfNeeded();
  }

  function releaseOwnership(){
    const cur = readOwner();
    if (cur && cur.id === TAB_ID){
      clearOwner();
      broadcast({ type: "release", id: TAB_ID });
    }
    stopHeartbeat();
    // keep userAudioPref cleanup as before:
    try { localStorage.removeItem("userAudioPref"); } catch(e){}
  }

  // storage message handler (fallback + "ar_bcast" ping)
  window.addEventListener("storage", (e)=>{
    if (!e.key) return;
    if (e.key === AR_KEY){
      // owner changed
      const owner = readOwner();
      if (owner && owner.id !== TAB_ID && isOwnerFresh(owner)){
        showInactiveMessage();
      }
      // if owner is null (released), do nothing â€” user can start
    } else if (e.key === "ar_bcast"){
      // cross-browser event ping â€” parse and react if needed
      try {
        const msg = JSON.parse(e.newValue);
        if (msg && msg.type === "claim" && msg.id !== TAB_ID){
          const owner = readOwner();
          if (owner && owner.id === msg.id && isOwnerFresh(owner)){
            showInactiveMessage();
          }
        } else if (msg && msg.type === "release"){
          // released - let UI remain (start button shown)
        }
      } catch(e){}
    }
  });

  // BroadcastChannel listener
  if (bc){
    bc.onmessage = (ev)=>{
      const msg = ev.data;
      if (!msg) return;
      if (msg.type === "claim" && msg.id !== TAB_ID){
        const owner = readOwner();
        if (owner && owner.id === msg.id && isOwnerFresh(owner)){
          showInactiveMessage();
        }
      } else if (msg.type === "release"){
        // released - allow start
      }
    };
  }

  // Visibility changes: start/stop heartbeat appropriately
  document.addEventListener('visibilitychange', ()=>{
    if (document.visibilityState === 'visible'){
      // if we own it, resume heartbeat to keep lastSeen fresh
      const cur = readOwner();
      if (cur && cur.id === TAB_ID) startHeartbeatIfNeeded();
    } else {
      // stop updating while hidden (timers on iOS may freeze); expiry will be used by newcomers
      stopHeartbeat();
    }

    // also handle UI when returning to page
    if (!document.hidden){
      // show overlay / restart button logic from your original flow
      const whiteOverlay = document.getElementById("whiteOverlay");
      const arScene = document.getElementById("arScene");
      const startBtn = document.getElementById("startAR");
      const restartBtn = document.getElementById("restartAR");
      whiteOverlay.style.display="block";
      arScene.style.display="none";
      if (window.__arStartedOnce) {
        startBtn.style.display="none";
        restartBtn.style.display="block";
        window.__arButtonPressed = false;
      } else {
        startBtn.style.display="block";
        restartBtn.style.display="none";
      }
    }
  });

  // pagehide / beforeunload â€” best-effort release
  window.addEventListener("pagehide", releaseOwnership);
  window.addEventListener("beforeunload", releaseOwnership);

  // Initial claim check (run shortly after script load)
  setTimeout(()=>{
    const owner = readOwner();
    if (owner && owner.id !== TAB_ID && isOwnerFresh(owner)){
      // another tab currently owns AR -> show inactive message
      showInactiveMessage();
      return;
    }
    // Either no owner, or owner is stale -> claim and init AR
    claimOwnership();
    initAR(); // proceed to start the rest of your AR initialization
  }, 50);

  // ------------- Your AR logic (kept essentially the same) -------------
  // I placed it in a function so we can call initAR() after claiming ownership.
  async function initAR(){
    // small global flags used by visibility handler
    window.__arStartedOnce = false;
    window.__arButtonPressed = false;

    const whiteOverlay = document.getElementById("whiteOverlay");
    const startBtn = document.getElementById("startAR");
    const restartBtn = document.getElementById("restartAR");
    const audioToggleBtn = document.getElementById("audioToggle");
    const videoA = document.getElementById("videoA");
    const videoB = document.getElementById("videoB");
    const videoPlaneA = document.getElementById("videoPlaneA");
    const videoPlaneB = document.getElementById("videoPlaneB");
    const targetEl = document.getElementById("target0");
    const arScene = document.getElementById("arScene");
    const stillWatchingContainer = document.getElementById("stillWatchingContainer");
    const stillWatchingBtn = document.getElementById("stillWatchingBtn");
    const TOTAL_VIDEOS = 60;

    let lastIndex=-1, activeVideo=videoA, nextVideo=videoB, activePlane=videoPlaneA, nextPlane=videoPlaneB;
    let startClicked=false, arStartedOnce=false, arButtonPressed=false, isActive=false, loopCount=0, targetCurrentlyVisible=false;
    const LOOP_LIMIT=3;

    let userAudioPreference = localStorage.getItem("userAudioPref");
    userAudioPreference = userAudioPreference===null?true:userAudioPreference!=="false";

    let audioCtx, audioBuffer, audioSource, audioLoaded=false, audioStartTime=0, audioOffset=0;

    async function loadAudioOnce(){
      if(audioLoaded) return;
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const response = await fetch("./assets/audio/background.mp3");
      const arrayBuffer = await response.arrayBuffer();
      audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      audioLoaded = true;
    }

    function playAudio(){
      if(!audioBuffer) return;
      stopAudio();
      audioSource = audioCtx.createBufferSource();
      audioSource.buffer = audioBuffer;
      audioSource.loop=true;
      audioSource.connect(audioCtx.destination);
      audioStartTime = audioCtx.currentTime - audioOffset;
      audioSource.start(0,audioOffset % audioBuffer.duration);
      audioToggleBtn.textContent="ðŸ”Š";
    }

    function stopAudio(){
      if(audioSource){
        try{ audioSource.stop(); audioOffset=(audioCtx.currentTime-audioStartTime) % audioBuffer.duration; }catch{}
        audioSource.disconnect(); audioSource=null;
      }
      audioToggleBtn.textContent="ðŸ”‡";
    }

    function pickRandomIndex(){
      let idx;
      do{ idx=Math.floor(Math.random()*TOTAL_VIDEOS); }while(idx===lastIndex);
      lastIndex=idx;
      return idx;
    }

    function preloadVideo(videoEl){
      const idx = pickRandomIndex();
      videoEl.src = `./assets/videos/target0_random_${idx}.mp4`;
      videoEl.currentTime=0;
      videoEl.load();
    }

    function swapVideo(){
      const flip=Math.random()<0.5?-1:1;
      nextPlane.setAttribute("scale",`${flip} 1 1`);
      nextPlane.setAttribute("visible",true);
      activePlane.setAttribute("visible",false);
      nextVideo.currentTime=0;
      nextVideo.play();
      [activeVideo,nextVideo]=[nextVideo,activeVideo];
      [activePlane,nextPlane]=[nextPlane,activePlane];
      preloadVideo(nextVideo);
      loopCount++;
      if(loopCount>=LOOP_LIMIT) showStillWatching();
    }

    function monitorVideo(){
      if(isActive && activeVideo.duration>0 && activeVideo.currentTime>=activeVideo.duration-0.05){
        swapVideo();
      }
      requestAnimationFrame(monitorVideo);
    }

    function showStillWatching(){
      isActive=false;
      activeVideo.pause();
      nextVideo.pause();
      stopAudio();
      audioToggleBtn.style.display="none";
      stillWatchingContainer.style.display="flex";
    }

    stillWatchingBtn.addEventListener("click", async ()=>{
      stillWatchingContainer.style.display="none";
      loopCount=0;
      isActive=true;
      activeVideo.play();
      activePlane.setAttribute("visible",true);
      if(userAudioPreference){ await loadAudioOnce(); playAudio(); }
      audioToggleBtn.style.display="block";
    });

    async function handleTargetFound(){
      if(!arButtonPressed) return;
      isActive=true;
      activePlane.setAttribute("visible",true);
      arScene.style.background="#ffffff";
      if(!activeVideo.src){ preloadVideo(activeVideo); preloadVideo(nextVideo); }
      activeVideo.play();
      if(userAudioPreference){ await loadAudioOnce(); playAudio(); }
      audioToggleBtn.style.display="block";
    }

    startBtn.addEventListener("click",()=>{
      startClicked = true;
      arButtonPressed = true;
      arStartedOnce = true;
      window.__arStartedOnce = true;
      window.__arButtonPressed = true;
      whiteOverlay.style.display="none";
      arScene.style.display="block";
      monitorVideo();
      if(targetCurrentlyVisible) handleTargetFound();
    });

    restartBtn.addEventListener("click",()=>{
      startClicked = true;
      arButtonPressed = true;
      whiteOverlay.style.display="none";
      arScene.style.display="block";
      monitorVideo();
      if(targetCurrentlyVisible) handleTargetFound();
    });

    audioToggleBtn.addEventListener("click", async ()=>{
      await loadAudioOnce();
      if(!audioSource){ playAudio(); userAudioPreference=true; }
      else{ stopAudio(); userAudioPreference=false; }
      localStorage.setItem("userAudioPref",userAudioPreference);
    });

    targetEl.addEventListener("targetFound", ()=>{
      targetCurrentlyVisible = true;
      if(arButtonPressed) handleTargetFound();
    });

    targetEl.addEventListener("targetLost", ()=>{
      targetCurrentlyVisible=false;
      isActive=false;
      activePlane.setAttribute("visible",false);
      nextPlane.setAttribute("visible",false);
      arScene.style.background=null;
      activeVideo.pause();
      nextVideo.pause();
      stopAudio();
      audioToggleBtn.style.display="none";
    });

    document.addEventListener("visibilitychange", ()=>{
      if(document.hidden){
        isActive=false;
        activeVideo.pause();
        nextVideo.pause();
        stopAudio();
        audioToggleBtn.style.display="none";
        activePlane.setAttribute("visible",false);
        nextPlane.setAttribute("visible",false);
      } else {
        whiteOverlay.style.display="block";
        arScene.style.display="none";
        audioToggleBtn.style.display="none";

        if(arStartedOnce){
          startBtn.style.display="none";
          restartBtn.style.display="block";
          arButtonPressed = false;
        } else {
          startBtn.style.display="block";
          restartBtn.style.display="none";
        }
      }
    });

    [videoA,videoB].forEach(v=>{ v.currentTime=0; v.play(); v.pause(); });
    preloadVideo(videoA);
    preloadVideo(videoB);
    await loadAudioOnce();
  }

})();
</script>

</body>
</html>
